import Field from"./Field";const defaultOptions={justRenderAfterValidate:!0,defaultMessage:"",displayErrorCallback:text=>text};export default class SimpleFormValidation{constructor(params){this.options={...defaultOptions,...params},this.rules=[],this.errors={},this._validateHasRan=!1}canRender(){return!this.options.justRenderAfterValidate||this.options.justRenderAfterValidate&&this._validateHasRan}reset(){this.rules=[],this._validateHasRan=!1,this.resetErrors()}addError(stateKeyName,msg){this.errors[stateKeyName]=msg}resetErrors(){this.errors={}}isValid(){return!this.hasErrors()}hasErrors(){return Object.keys(this.errors).length>0}renderAllErrors(){if(!this.canRender())return null;const errorList=[];for(var key in this.errors)errorList.push(this.options.displayErrorCallback(this.errors[key]));return errorList}renderError(field,value){if(!this.canRender())return null;if(void 0===this.rules[field])return null;if(this.rules[field].run(value),this.rules[field].hasError()){const errorMessage=this.rules[field].getMessage();return this.addError(field,errorMessage),""==errorMessage&&console.warn(`Empty validator message to '${field}'.`),this.options.displayErrorCallback(errorMessage)}return delete this.errors[field],null}field(fieldName,reset=!1){return(reset||void 0===this.rules[fieldName])&&(this.rules[fieldName]=new Field(this.options.defaultMessage)),this.rules[fieldName]}validate(state){return new Promise((resolve,reject)=>{if(!this.validateSync(state))throw this.errors;resolve()})}validateSync(state){for(var key in this._validateHasRan=!0,this.resetErrors(),this.rules){const validator=this.rules[key].validator;!0!==validator.run(state[key])&&this.addError(key,validator.getMessage())}return!this.hasErrors()}};